%[text] Add static stability constraints to optimization problem.
function [aircraft, wing, vTail, designprob] = ...
        addStability(aircraft, wing, fuselage, hTail, vTail, payload, ...
                     designprob, fixedWing, CruiseState)
%[text] ### Mean Aerodynamic Chord
wing.MAC = 2/3*wing.RootChord...
    *(1+wing.TaperRatio*wing.TaperRatio^2)...
    /(1+wing.TaperRatio);
vTail.MACLoc = vTail.HalfSpan/2;
%[text] ### Neutral Point
% Wing Contribution
aircraft.NeutralPoint = wing.ClAlpha*wing.Xac;

% Tail Contribution
aircraft.NeutralPoint = aircraft.NeutralPoint...
    +(hTail.Efficiency*hTail.PlanformArea/wing.PlanformArea*...
    hTail.ClAlpha*(1-hTail.Downwash)*hTail.Xac);

% Final Normalization
aircraft.NeutralPoint = aircraft.NeutralPoint/(wing.ClAlpha...
    +hTail.Efficiency*hTail.PlanformArea/wing.PlanformArea*...
    hTail.ClAlpha*(1-hTail.Downwash));
%[text] Add the helper functions to the MATLAB path.
addpath('AerodynamicCoefficients');
addpath('MassMomentofInertia');
%[text] ## Aerodynamic Coefficients used by FixedWing object
%[text] To create an Aero.FixedWing object, calculate all 21 aerodynamic coefficients that define the aircraft's dynamics response.
%[text] Set the options to specify that the output is a 3-element row vector and turn on analysis and evaluation reuse to speed up the optimization.
options = {'OutputSize', [1 3], 'ReuseEvaluation', true, 'Analysis', 'on'};

% Longitudinal Dynamics
CZero = fcn2optimexpr(@ZeroLiftCoeffs, ...
    wing.ClAlpha, wing.Airfoil, wing.MeanChord, aircraft.Cd0, ...
    aircraft.Xcg, aircraft.NeutralPoint, ...
    options{:});
CL0 = CZero(2);

CAlpha = fcn2optimexpr(@AoACoeffs, ...
    aircraft.ClAlpha, wing.AspectRatio, wing.K, wing.MeanChord, ...
    aircraft.Xcg, aircraft.NeutralPoint, CL0, ...
    options{:});

CAlphaDot = fcn2optimexpr(@AoARateCoeffs, ...
    wing.AspectRatio, wing.TaperRatio, wing.MeanChord,...
    wing.PlanformArea, 2*wing.HalfSpan, hTail.PlanformArea, ...
    hTail.ClAlpha, hTail.Xac, aircraft.Xcg, ...
    options{:});

Cq = fcn2optimexpr(@PitchRateCoeffs, ...
    hTail.ClAlpha, hTail.Xac, wing.MeanChord, aircraft.Xcg, ...
    hTail.PlanformArea, wing.PlanformArea, ...
    options{:});

% Lateral Dynamics
CBeta = fcn2optimexpr(@BetaCoeffs, ...
    hTail.PlanformArea, vTail.PlanformArea, wing.PlanformArea, ...
    2*hTail.HalfSpan, 2*wing.HalfSpan, vTail.Xac,  vTail.MACLoc, ...
    vTail.CFBeta, wing.ClAlpha, hTail.ClAlpha, CL0, ...
    options{:});
CYBeta = CBeta(1);

Cp = fcn2optimexpr(@RollRateCoeffs, ...
    vTail.Xac, vTail.MACLoc, 2*hTail.HalfSpan, 2*wing.HalfSpan, ...
    hTail.PlanformArea, vTail.PlanformArea, wing.PlanformArea, ...
    aircraft.Cd0, vTail.CFBeta, CYBeta, ...
    options{:});

Cr = fcn2optimexpr(@YawRateCoeffs, ...
    vTail.Xac, vTail.MACLoc, 2*hTail.HalfSpan, 2*wing.HalfSpan, ...
    hTail.PlanformArea, vTail.PlanformArea, wing.PlanformArea, ...
    hTail.ClAlpha, vTail.CFBeta, CL0, CYBeta, wing.ClAlpha, ...
    wing.TaperRatio, wing.Cd0, ...
    options{:});

BodyCoefficients = [CZero CAlpha CAlphaDot Cq CBeta Cp Cr]';
%[text] ## Inertia Matrix Calculation
%[text] Use the component build-up method to calculate the mass moment of intertia of the aircraft, which is also needed to create the Aero.FixedWing object. Each function calculates the 3-by-3 inertia matrix for a component with respect to the aircraft's center of gravity. Then, the matrices are added together.
%[text] Set the options to specify that the output is a 3-by-3 matrix, and turn on analysis and evaluation reuse to speed up the optimization.
options = {'OutputSize', [3 3], 'ReuseEvaluation', true, 'Analysis', 'on'};

% Wing Inertia Matrix
Iw = fcn2optimexpr(@wingInertia, ...
    wing.HalfSpan, wing.RootChord, wing.TaperRatio, ...
    wing.Density, wing.XLoc, aircraft.Xcg, ...
    options{:});

% Horizontal Tail Inertia Matrix
Ih = fcn2optimexpr(@hTailInertia, ...
    hTail.HalfSpan, hTail.Chord, hTail.Density, ...
    hTail.XLoc, aircraft.Xcg, ...
    options{:});

% Vertical Tail Inertia Matrix
Iv = fcn2optimexpr(@vTailInertia, ...
    vTail.HalfSpan, vTail.Chord, vTail.Density, ...
    vTail.XLoc, aircraft.Xcg, ...
    options{:});

% Payload Inertia Matrix
Ip = fcn2optimexpr(@payloadInertia, ...
    payload.Spherical, payload.XLoc, payload.Boxed.Length, ...
    payload.Boxed.Mass, payload.Boxed.Height, fuselage.SideLength, ...
    aircraft.Xcg, ...
    options{:});

% Fuselage Inertia Matrix
If = fcn2optimexpr(@fuselageInertia, ...
    fuselage.Mass, fuselage.SideLength, fuselage.Length, ...
    fuselage.Xcg, aircraft.Xcg, ...
    options{:});

% Aircraft Inertia Matrix
inertiaMatrix = fcn2optimexpr(@aircraftInertia, ...
    Iw, Ih, Iv, Ip, If, aircraft.Avionics, aircraft.Xcg, ...
    options{:});
%[text] ## Stability Derivatives using FixedWing object
%[text] Use the staticStability function to compute all 48 static stability derivatives of the aircraft. Only 10 of them have a noticeable effect on the aircraft's stability, reducing the overall number of constraints.
stabilityDerivatives = fcn2optimexpr(@computeDerivatives,...
    fixedWing, BodyCoefficients, CruiseState, inertiaMatrix, ...
    aircraft.Xcg, aircraft.NeutralPoint, wing.PlanformArea, wing.HalfSpan, ...
    hTail.Xac, hTail.Chord, aircraft.Mass, ...
    'OutputSize', [10 1], 'ReuseEvaluation', true, 'Analysis', 'off');

designprob.Constraints.CD_U = stabilityDerivatives(1) <= 0;
designprob.Constraints.Cm_U = stabilityDerivatives(2) <= 0;
designprob.Constraints.CY_V = stabilityDerivatives(3) <= 0;
designprob.Constraints.CL_W = stabilityDerivatives(4) <= 0;
designprob.Constraints.Cm_Alpha = stabilityDerivatives(5) <= 0;
designprob.Constraints.Cl_Beta = stabilityDerivatives(6) <= 0;
designprob.Constraints.Cn_Beta = stabilityDerivatives(7) >= 0;
designprob.Constraints.Cl_P = stabilityDerivatives(8) <= 0;
designprob.Constraints.Cm_Q = stabilityDerivatives(9) <= 0;
designprob.Constraints.Cn_R = stabilityDerivatives(10) <= 0;
end
%[text] *Copyright 2022 The MathWorks, Inc.*

%[appendix]{"version":"1.0"}
%---
%[metadata:view]
%   data: {"layout":"onright","rightPanelPercent":40}
%---
